/**
 * File tree component
 */
import apiService from '../services/api.js';
import { showError } from '../utils/uiUtils.js';

class FileTreeComponent {
    constructor() {
        this.fileTreeElement = document.getElementById('fileTree');
        this.currentSelectedItem = null;
        this.onFileSelect = null; // Callback for when a file is selected
        this.draggedItem = null; // Track the item being dragged
        this.expandedFolders = new Set(); // Track expanded folders
        
        // Load expanded folders from localStorage if available
        this.loadExpandedFoldersState();
        
        // Initialize drag and drop event listeners for the file tree container
        this.initDragAndDrop();
    }
    
    /**
     * Load expanded folders state from localStorage
     */
    loadExpandedFoldersState() {
        try {
            const savedState = localStorage.getItem('expandedFolders');
            if (savedState) {
                const expandedFolderPaths = JSON.parse(savedState);
                this.expandedFolders = new Set(expandedFolderPaths);
                console.log('Loaded expanded folders state:', expandedFolderPaths);
            }
        } catch (error) {
            console.error('Error loading expanded folders state:', error);
            this.expandedFolders = new Set();
        }
    }
    
    /**
     * Save expanded folders state to localStorage
     */
    saveExpandedFoldersState() {
        try {
            const expandedFolderPaths = Array.from(this.expandedFolders);
            localStorage.setItem('expandedFolders', JSON.stringify(expandedFolderPaths));
            console.log('Saved expanded folders state:', expandedFolderPaths);
        } catch (error) {
            console.error('Error saving expanded folders state:', error);
        }
    }
    
    /**
     * Initialize drag and drop event handlers
     */
    initDragAndDrop() {
        // Allow the file tree to accept drops
        this.fileTreeElement.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.fileTreeElement.classList.add('drag-over');
        });
        
        this.fileTreeElement.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.fileTreeElement.classList.remove('drag-over');
        });
        
        this.fileTreeElement.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.fileTreeElement.classList.remove('drag-over');
            
            if (this.draggedItem && e.target.closest('.file-tree-item')) {
                const targetItem = e.target.closest('.file-tree-item');
                const targetPath = targetItem.dataset.path;
                const sourcePath = this.draggedItem.dataset.path;
                
                try {
                    await this.moveFileOrFolder(sourcePath, targetPath);
                    
                    // Ensure target folder is expanded after moving a file into it
                    if (targetItem.dataset.type === 'folder') {
                        this.expandedFolders.add(targetPath);
                        this.saveExpandedFoldersState();
                        console.log(`Target folder expanded: ${targetPath}`);
                    }
                    
                    await this.loadFileTree(); // Refresh the file tree
                } catch (error) {
                    showError('Failed to move item: ' + error.message);
                }
            }
        });
    }
    
    /**
     * Move a file or folder to a new location
     * @param {string} sourcePath - The path of the file/folder to move
     * @param {string} targetPath - The destination path
     */
    async moveFileOrFolder(sourcePath, targetPath) {
        try {
            await apiService.moveFileOrFolder(sourcePath, targetPath);
        } catch (error) {
            throw new Error(`Failed to move item: ${error.message}`);
        }
    }
    
    /**
     * Set callback for file selection
     * @param {function} callback - Function to call when a file is selected
     */
    setOnFileSelectCallback(callback) {
        this.onFileSelect = callback;
    }
    
    /**
     * Load the file tree
     */
    async loadFileTree() {
        try {
            const files = await apiService.getFileTree();
            this.renderFileTree(files);
        } catch (error) {
            showError('Failed to load file tree: ' + error.message);
        }
    }
    
    /**
     * Render the file tree
     * @param {Array} files - Array of file objects
     */
    renderFileTree(files) {
        // Clear the file tree
        this.fileTreeElement.innerHTML = '';
        
        // Group files by parent path
        const filesByParent = {};
        
        // Add root level
        filesByParent[''] = [];
        
        // Group files by parent path
        files.forEach(file => {
            if (!filesByParent[file.parentPath]) {
                filesByParent[file.parentPath] = [];
            }
            filesByParent[file.parentPath].push(file);
        });
        
        // Render root level files and folders
        const rootFiles = filesByParent[''] || [];
        rootFiles.sort((a, b) => {
            // Sort folders first, then by name
            if (a.type === 'folder' && b.type !== 'folder') return -1;
            if (a.type !== 'folder' && b.type === 'folder') return 1;
            return a.name.localeCompare(b.name);
        });
        
        this.renderFileTreeLevel(rootFiles, this.fileTreeElement, filesByParent);
        
        // Add a click handler to the file tree to prevent event bubbling
        this.fileTreeElement.addEventListener('click', (e) => {
            e.stopPropagation();
        });
    }
    
    /**
     * Render a level of the file tree
     * @param {Array} files - Files at this level
     * @param {HTMLElement} container - Container element for this level
     * @param {object} filesByParent - Files grouped by parent path
     */
    renderFileTreeLevel(files, container, filesByParent) {
        const ul = document.createElement('ul');
        ul.className = 'file-tree-list';
        container.appendChild(ul);
        
        files.forEach(file => {
            const li = document.createElement('li');
            li.className = 'file-tree-item draggable';
            li.dataset.path = file.path;
            li.dataset.type = file.type;
            li.draggable = true; // Make the item draggable
            
            const icon = document.createElement('span');
            icon.className = 'file-icon';
            // Use different icons for expanded/collapsed folders
            if (file.type === 'folder') {
                icon.textContent = '📁';
                icon.classList.add('folder-icon');
            } else {
                icon.textContent = this.getFileIcon(file.type);
            }
            
            const name = document.createElement('span');
            name.className = 'file-name';
            name.textContent = file.name;
            
            li.appendChild(icon);
            li.appendChild(name);
            
            // Append the li to the ul
            ul.appendChild(li);
            
            // Add drag and drop events
            li.addEventListener('dragstart', (event) => {
                this.draggedItem = li;
                li.classList.add('dragging');
                event.dataTransfer.setData('text/plain', file.path);
                event.dataTransfer.effectAllowed = 'move';
            });
            
            li.addEventListener('dragend', () => {
                li.classList.remove('dragging');
                this.draggedItem = null;
            });
            
            li.addEventListener('dragover', (event) => {
                event.preventDefault();
                event.stopPropagation();
                if (file.type === 'folder' && this.draggedItem !== li) {
                    li.classList.add('drag-over');
                }
            });
            
            li.addEventListener('dragleave', (event) => {
                event.preventDefault();
                event.stopPropagation();
                li.classList.remove('drag-over');
            });
            
            li.addEventListener('drop', async (event) => {
                event.preventDefault();
                event.stopPropagation();
                li.classList.remove('drag-over');
                
                if (this.draggedItem && file.type === 'folder') {
                    const sourcePath = this.draggedItem.dataset.path;
                    const targetPath = file.path;
                    
                    try {
                        await this.moveFileOrFolder(sourcePath, targetPath);
                        
                        // Ensure target folder is expanded after moving a file into it
                        this.expandedFolders.add(targetPath);
                        this.saveExpandedFoldersState();
                        
                        // Remove the 'collapsed' class from the target folder and show its children
                        const targetElement = document.querySelector(`.file-tree-item[data-path="${targetPath}"]`);
                        if (targetElement) {
                            targetElement.classList.remove('collapsed');
                            const childContainer = targetElement.querySelector('.file-tree-children');
                            if (childContainer) {
                                childContainer.classList.remove('hidden');
                            }
                        }
                        
                        await this.loadFileTree(); // Refresh the file tree
                    } catch (error) {
                        showError('Failed to move item: ' + error.message);
                    }
                }
            });
            
            // If it's a file, add click event to select it
            if (file.type !== 'folder') {
                li.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.selectItem(li, file);
                });
            }
            
            // If it's a folder, handle children
            if (file.type === 'folder') {
                const childPath = file.path + '/';
                const children = filesByParent[childPath] || [];
                
                // Create container for children
                const childContainer = document.createElement('div');
                childContainer.className = 'file-tree-children';
                
                // Check if this folder was previously expanded
                const isExpanded = this.expandedFolders.has(file.path);
                console.log(`Folder ${file.path}: expanded=${isExpanded}, children=${children.length}`);
                
                // Add expand/collapse classes and hide/show container
                li.classList.add('has-children');
                
                if (!isExpanded) {
                    li.classList.add('collapsed');
                    childContainer.classList.add('hidden');
                }
                
                // Append the child container to the li element (BEFORE populating it)
                li.appendChild(childContainer);
                
                // Sort and render children if any
                if (children.length > 0) {
                    children.sort((a, b) => {
                        // Sort folders first, then by name
                        if (a.type === 'folder' && b.type !== 'folder') return -1;
                        if (a.type !== 'folder' && b.type === 'folder') return 1;
                        return a.name.localeCompare(b.name);
                    });
                    
                    this.renderFileTreeLevel(children, childContainer, filesByParent);
                }
                
                // Add click handler for folders
                li.addEventListener('click', (event) => {
                    event.stopPropagation();
                    event.preventDefault();
                    
                    // Toggle collapsed state
                    li.classList.toggle('collapsed');
                    childContainer.classList.toggle('hidden');
                    
                    // Track expanded folders
                    if (li.classList.contains('collapsed')) {
                        this.expandedFolders.delete(file.path);
                    } else {
                        this.expandedFolders.add(file.path);
                        console.log(`Expanded folder: ${file.path}`);
                    }
                    
                    // Save expanded folders state
                    this.saveExpandedFoldersState();
                    
                    // Update visual selection
                    if (this.currentSelectedItem) {
                        this.currentSelectedItem.classList.remove('selected');
                    }
                    li.classList.add('selected');
                    this.currentSelectedItem = li;
                });
            }
        });
    }
    
    /**
     * Get icon for file type
     * @param {string} fileType - File type
     * @returns {string} - Icon character
     */
    getFileIcon(fileType) {
        switch (fileType) {
            case 'txt': return '📄';
            case 'md': return '📝';
            case 'pdf': return '📑';
            case 'epub': return '📚';
            default: return '📄';
        }
    }
    
    /**
     * Select a file or folder in the tree
     * @param {HTMLElement} element - The li element to select
     * @param {object} fileData - The file data
     */
    selectItem(element, fileData) {
        // Deselect previously selected item
        if (this.currentSelectedItem) {
            this.currentSelectedItem.classList.remove('selected');
        }
        
        // Select new item
        element.classList.add('selected');
        this.currentSelectedItem = element;
        
        // Only call the callback for files, not folders
        if (this.onFileSelect && fileData.type !== 'folder') {
            this.onFileSelect(fileData);
        }
    }
}

// Export singleton instance
const fileTreeComponent = new FileTreeComponent();
export default fileTreeComponent;
